# regionTree (n-dimensional QuadTree)

Нигде в интернете я не нашёл нормальное объяснение алгоритма QuadTree, поэтому я его напишу сам.

RegionTree - Структура данных, хранящая переменное число точек в n-мерном пространстве в дереве. В качестве примера есть octtree и vectree (подробнее в википедии или где-либо ещё). В данной реализации каждый узел дерева имеет такой вид:
1. Динамический массив (размера EM) точек и число E, отвечающее за их количество.
2. Массив размера 2 D указателей на дочерние узлы.
В моём случае EM=3, 1<=D<=7. (D можно сделать больше, но тогда индексы дочерних вершин будут вне uint8_t, EM можно поменять ручками)

В общем случае узел имеет 4 состояния (getState()):
0. Узел не инициализирован (null)
1. Узел инициализирован, но не заполнен. полностью (E<EM)
2. Узел заполнен полностью (E=EM)
3. Узел переполнен и разделён (E=EM, v=null)

Зная это можно реализовать метод add(vec p) - добавление новой точки
0. случай 0 полагаем невозможным, т.к. это метод класса узла
1. добавляем вершину и увеличиваем счётчик
2. выполняем метод split() и переходим к случаю 3
3. определяем индекс (pointToId()) дочернего узла, если по этому индексу он null, создаём его(координату узла считаем с помощью idToDelta()). Добавляем в него вершину (используя метод add(), т.к. дочерний узел может быть в состояниях 1,2,3)

split():
1. Для каждой из точек массива определяем индекс дочернего узла, если по этому индексу он null, создаём его. Добавляем в него вершину (используя метод add(), т.к. дочерний узел может быть в состояниях 1 b 2 в некотором случае)
2. Удаляем массив и делаем его null.

часть метода split() и add() вынесем для краткости в вспомогательный add_()
Методы размера дерева, количества точек и удаления совпадают с обычными деревьями.

Теперь реализуем метод поиска минимального расстояния до точки из дерева. Будем рассматривать точки, находящиеся на расстоянии<=r от данной точки p, постоянно сужая оценку r.
Случаи 1 и 2:
применим r = min(r, length(v[i]-p)) для всех точек массива
случай 3:
1. Найдём расстояния до дочерних узлов с помощью формулы расстояния до куба (см. inigo quilez: 3d sdf)
2. Отсортируем пары (узел*, расстояние) по возрастанию расстояния.
3. Вызываем эту же функцию для дочерних узлов в данном порядке (пока расстояние меньше r)

Можно расширить данные алгоритмы - добавить в структуру vec void-указатель, чтобы хранить произвольные данные, или вместо массива vec[] хранить pair<vec,T>[], но этим уже можете заняться сами.
